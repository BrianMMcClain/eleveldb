From slfritchie's leveldb source repo:

  commit bc8f12bf9d19d2b8fdc2eccecf88c528e8f053a6
  Author: Scott Lystig Fritchie <slfritchie@snookles.com>
  Date:   Mon Jan 23 20:50:01 2012 -0600
  
      Add extra event logging to "LOG" file
      
      To better understand the LevelDB compaction process (including file
      selection and timing), we've added these extra event logging calls
      to code that seemed most opaque.  Many thanks to Jon Meredith for
      hacking them up.

diff --git a/db/db_impl.cc b/db/db_impl.cc
index b4df80d..3ca6337 100644
--- a/db/db_impl.cc
+++ b/db/db_impl.cc
@@ -33,6 +33,10 @@
 #include "util/logging.h"
 #include "util/mutexlock.h"
 
+extern "C" {
+    extern pthread_t bg_id;
+}
+
 namespace leveldb {
 
 struct DBImpl::CompactionState {
@@ -584,6 +588,9 @@ void DBImpl::MaybeScheduleCompaction() {
   } else {
     bg_compaction_scheduled_ = true;
     env_->Schedule(&DBImpl::BGWork, this);
+    if (bg_id == pthread_self()) {
+        Log(options_.info_log, "Background thread rescheduled for compaction");
+    }
   }
 }
 
@@ -1159,7 +1166,10 @@ Status DBImpl::MakeRoomForWrite(bool force) {
   assert(logger_ != NULL);
   bool allow_delay = !force;
   Status s;
+  unsigned int loops = 0;
+  unsigned int l0files = 0;
   while (true) {
+    loops++;
     if (!bg_error_.ok()) {
       // Yield previous error
       s = bg_error_;
@@ -1167,6 +1177,8 @@ Status DBImpl::MakeRoomForWrite(bool force) {
     } else if (
         allow_delay &&
         versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
+      Log(options_.info_log, "waiting - slowdown - too many L0 %u > %u... %d loops\n",
+         l0files, config::kL0_SlowdownWritesTrigger, loops);
       // We are getting close to hitting a hard limit on the number of
       // L0 files.  Rather than delaying a single write by several
       // seconds when we hit the hard limit, start delaying each
@@ -1184,10 +1196,13 @@ Status DBImpl::MakeRoomForWrite(bool force) {
     } else if (imm_ != NULL) {
       // We have filled up the current memtable, but the previous
       // one is still being compacted, so we wait.
+      Log(options_.info_log, "waiting - imm != NULL (%p)... %d loops\n", imm_, loops);
       bg_cv_.Wait();
-    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {
+    } else if ((l0files=versions_->NumLevelFiles(0)) >= config::kL0_StopWritesTrigger) {
+    //} else if ((l0files=versions_->NumLevelBytes(0)) >= 10*1024*1024) {
       // There are too many level-0 files.
-      Log(options_.info_log, "waiting...\n");
+      Log(options_.info_log, "waiting - too many L0 %u > %u... %d loops\n",
+         l0files, config::kL0_StopWritesTrigger, loops);
       bg_cv_.Wait();
     } else {
       // Attempt to switch to a new memtable and trigger compaction of old
@@ -1211,6 +1226,7 @@ Status DBImpl::MakeRoomForWrite(bool force) {
       MaybeScheduleCompaction();
     }
   }
+  Log(options_.info_log, "waited... %d loops\n", loops);
   return s;
 }
 
diff --git a/db/version_set.cc b/db/version_set.cc
index 7cf5197..afa7e09 100644
--- a/db/version_set.cc
+++ b/db/version_set.cc
@@ -4,6 +4,7 @@
 
 #include "db/version_set.h"
 
+#include <math.h>
 #include <algorithm>
 #include <stdio.h>
 #include "db/filename.h"
@@ -931,6 +932,7 @@ void VersionSet::Finalize(Version* v) {
   // Precomputed best level for next compaction
   int best_level = -1;
   double best_score = -1;
+  double scores[8] = { 0, 0, 0, 0, 0, 0, 0, 0};
 
   for (int level = 0; level < config::kNumLevels-1; level++) {
     double score;
@@ -946,19 +948,33 @@ void VersionSet::Finalize(Version* v) {
       // file size is small (perhaps because of a small write-buffer
       // setting, or very high compression ratios, or lots of
       // overwrites/deletions).
-      score = v->files_[level].size() /
-          static_cast<double>(config::kL0_CompactionTrigger);
+          VersionSet::LevelSummaryStorage tmp;
+      double old_score = v->files_[level].size() /
+            static_cast<double>(config::kL0_CompactionTrigger);
+      int num_files = v->files_[level].size();
+      if (0 && num_files >= config::kL0_StopWritesTrigger) {
+        score = 1e6;
+      } else {
+        score = old_score; //(double) (1 << v->files_[level].size());
+      }
+      Log(options_->info_log,
+        "core level-0 files = %d old_score = %.1f score = %.1f trigger=%.1f\n", num_files, old_score, score, static_cast<double>(config::kL0_CompactionTrigger));
     } else {
       // Compute the ratio of current size to size limit.
       const uint64_t level_bytes = TotalFileSize(v->files_[level]);
       score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);
     }
+    scores[level] = score;
 
     if (score > best_score) {
       best_level = level;
       best_score = score;
     }
   }
+  VersionSet::LevelSummaryStorage tmp;
+  Log(options_->info_log,
+    "FinalizeScores best_level=%d  [%.1f, %.1f, %.1f, %.1f, %.1f, %.1f] %s\n",
+            best_level,scores[0], scores[1], scores[2], scores[3], scores[4], scores[5], LevelSummary(&tmp));
 
   v->compaction_level_ = best_level;
   v->compaction_score_ = best_score;
@@ -1161,6 +1177,7 @@ Compaction* VersionSet::PickCompaction() {
   // the compactions triggered by seeks.
   const bool size_compaction = (current_->compaction_score_ >= 1);
   const bool seek_compaction = (current_->file_to_compact_ != NULL);
+
   if (size_compaction) {
     level = current_->compaction_level_;
     assert(level >= 0);
diff --git a/util/env_posix.cc b/util/env_posix.cc
index cc73348..c2e0182 100644
--- a/util/env_posix.cc
+++ b/util/env_posix.cc
@@ -25,6 +25,10 @@
 #include "util/logging.h"
 #include "util/posix_logger.h"
 
+extern "C" {
+pthread_t bg_id;
+}
+
 namespace leveldb {
 
 namespace {
@@ -514,7 +518,9 @@ void PosixEnv::Schedule(void (*function)(void*), void* arg) {
   PthreadCall("unlock", pthread_mutex_unlock(&mu_));
 }
 
+
 void PosixEnv::BGThread() {
+  bg_id = pthread_self();
   while (true) {
     // Wait until there is an item that is ready to run
     PthreadCall("lock", pthread_mutex_lock(&mu_));
